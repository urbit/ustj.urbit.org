<!DOCTYPE html> 
<html lang="en" xml:lang="en" > 
<head><title>Ford Fusion</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="latex.css" />
<meta name="src" content="mss.tex" /> 
<script>window.MathJax = { tex: { tags: "ams", }, }; </script> 
 <script type="text/javascript" async="async" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>  
</head><body 
>
   <div class="maketitle">
                                                
                                                
                                                
                                                

<h2 class="titleHead">Ford Fusion</h2>
<div class="author" ><span 
class="ec-lmbx-12">Ted Blackman</span><span 
class="ec-lmbx-12"> </span><span 
class="ec-lmbx-12">~rovnys-ricfer</span>
<br />       <span 
class="ec-lmbx-12">Urbit Foundation</span></div><br />
<div class="date" ></div>
   </div>
   <section role="doc-abstract" class="abstract"> 
<h3 class="abstracttitle">
<span 
class="ec-lmbx-9">Abstract</span>
</h3>
     <!--l. 42--><p class="noindent" ><span 
class="ec-lmr-9">Ford Fusion was an overhaul of Urbit’s over-the-air</span>
     <span 
class="ec-lmr-9">upgrade   process   and   a   rewrite   of   its   build</span>
     <span 
class="ec-lmr-9">system. The new update system corrected a few</span>
     <span 
class="ec-lmr-9">long-standing  bugs  with  the  previous  one,  and</span>
     <span 
class="ec-lmr-9">the  new  build  system  is  simpler,  smaller  (by</span>
     <span 
class="ec-lmr-9">around 5,000 lines), and easier to manage. This</span>
     <span 
class="ec-lmr-9">historical report was published on the Urbit Blog</span>
     <span 
class="ec-lmr-9">as a capitulation of the project, which successfully</span>
     <span 
class="ec-lmr-9">revamped the Hoon code build system. It is lightly</span>
     <span 
class="ec-lmr-9">annotated to update the minor technical changes</span>
     <span 
class="ec-lmr-9">that have occurred since the original publication;</span>
     <span 
class="ec-lmr-9">this  is  intended  as  a  living  document  to  some</span>
     <span 
class="ec-lmr-9">extent. Ford Fusion remains the state of the art for</span>
     <span 
class="ec-lmr-9">building Urbit software as of writing.</span>
                                                
                                                
</p>
</section>
   <h3 class="likesectionHead"><a 
 id="x1-1000"></a>Contents</h3>
   <div class="tableofcontents">
    <span class="sectionToc" >1 <a 
href="#x1-20001" id="QQ2-1-2">Overview and Rationale</a></span>
<br />     <span class="subsectionToc" >1.1 <a 
href="#x1-30001.1" id="QQ2-1-3">Atomicity</a></span>
<br />     <span class="subsectionToc" >1.2 <a 
href="#x1-40001.2" id="QQ2-1-4">Self-Containment</a></span>
<br />     <span class="subsectionToc" >1.3 <a 
href="#x1-50001.3" id="QQ2-1-5">Order</a></span>
<br />    <span class="sectionToc" >2 <a 
href="#x1-60002" id="QQ2-1-6">How Updates Work Now</a></span>
<br />    <span class="sectionToc" >3 <a 
href="#x1-70003" id="QQ2-1-7">How Clay Validates a Desk</a></span>
<br />    <span class="sectionToc" >4 <a 
href="#x1-80004" id="QQ2-1-8">Ford Build Semantics</a></span>
<br />     <span class="subsectionToc" >4.1 <a 
href="#x1-90004.1" id="QQ2-1-9">The Three Types of Ford Builds: Files, Marks, and Casts</a></span>
<br />      <span class="subsubsectionToc" >4.1.1 <a 
href="#x1-100004.1.1" id="QQ2-1-10">File Builds</a></span>
<br />      <span class="subsubsectionToc" >4.1.2 <a 
href="#x1-110004.1.2" id="QQ2-1-11">Mark Builds</a></span>
<br />      <span class="subsubsectionToc" >4.1.3 <a 
href="#x1-120004.1.3" id="QQ2-1-12">Cast Builds</a></span>
<br />     <span class="subsectionToc" >4.2 <a 
href="#x1-130004.2" id="QQ2-1-13">Ford Runes</a></span>
<br />    <span class="sectionToc" >5 <a 
href="#x1-140005" id="QQ2-1-14">Future Work</a></span>
<br />    <span class="sectionToc" >6 <a 
href="#x1-150006" id="QQ2-1-15">Conclusion</a></span>
<br />    <span class="sectionToc" ><a 
href="#x1-16000" id="QQ2-1-16">References</a></span>
   </div>
<!--l. 52--><p class="noindent" ><span 
class="ec-lmri-10">This Ford Fusion description was released by </span><span 
class="ec-lmri-10">~rovnys-ricfer on</span>
<span 
class="ec-lmri-10">~2020.7.14.</span>
</p><!--l. 56--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">1   </span> <a 
 id="x1-20001"></a>Overview and Rationale</h3>
<!--l. 58--><p class="noindent" >Ford Fusion was an overhaul of Urbit’s over-the-air upgrade
process and a rewrite of its build system. The new update
system corrects a few long-standing bugs with the previous
one, and the new build system is simpler, smaller (by around
5,000 lines), and easier to manage.
                                                
                                                
</p><!--l. 60--><p class="indent" >   Since deployment of Ford Fusion to the livenet in late
June, over-the-air updates (<span class="small-caps">ota</span>s) have been much smoother.
Before Ford Fusion, it was common for an <span class="small-caps">ota</span> to take several
hours, use too much memory, and leave ships in inconsistent
states. After Ford Fusion, multiple <span class="small-caps">ota</span>s have been pushed
out, including kernelspace changes, and most users didn’t even
notice.
</p><!--l. 62--><p class="indent" >   Urbit has always been able to update itself <span class="small-caps">ota</span>, but this
process has often been rocky. Updating an operating system
kernel on-the-ﬂy is a diﬃcult problem in general, like
performing heart replacement surgery on yourself while
running a marathon. Code that allows Linux to update
its kernel in this way became a startup called Ksplice,
won multiple awards, and sold to Oracle. Even that, as
impressive as it is, and as brilliant as its programmers are,
can only perform certain limited kinds of patches to the
kernel.
</p><!--l. 64--><p class="indent" >   Urbit isn’t exactly a traditional operating system, so the
comparison is somewhat unfair, but the purpose of better
architecture is to create unfair comparisons. In this case,
because the Nock layer is frozen, upgrading everything
above that layer is easier. Upgrades are also facilitated by
pure-functional semantics, transactional event processing, a
type system oriented toward concrete data, and orthogonal
persistence. These features make it feasible for Urbit to
upgrade itself in the general case, not just some special
cases.
</p><!--l. 67--><p class="indent" >   Ford Fusion has ﬁxed the major upgrade issues of the past
by guaranteeing three properties that in retrospect are obvious
requirements, but, like much of Urbit, took many years and
rewrites to identify as such:
</p>
     <ul class="itemize1">
     <li class="itemize">
     <!--l. 70--><p class="noindent" >Atomic: the update should complete or fail in one
     transaction. If it fails, the system shouldn’t get stuck.
                                                
                                                
     </p></li>
     <li class="itemize">
     <!--l. 71--><p class="noindent" >Self-contained:    there    must    be    no    implicit
     dependencies or hysteresis (dependence on previous
     system states) when building the new software from
     source.
     </p></li>
     <li class="itemize">
     <!--l. 73--><p class="noindent" >Ordered: updates must be monotonically sequenced
     from the system’s lowest layer to highest.</p></li></ul>
<!--l. 76--><p class="indent" >   Let’s walk through them one by one.
</p><!--l. 78--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-30001.1"></a>Atomicity</h4>
<!--l. 80--><p class="noindent" >In previous versions of Urbit, updates failed atomicity by
deferring parts of the update to later events, which are
separate transactions that can fail independently. Generally,
each deferral causes an exponential increase in the number of
failure states that needed to be handled.
</p><!--l. 82--><p class="indent" >   We’ve learned that asynchronicity is an entropic state. A
system will tend toward more asynchronicity over time unless
eﬀort is put into keeping it synchronous. As developer
Jonathan Blow has noted (<a 
 id="x1-3001"></a> Blow (2019), 42m27s), the
language server protocol has turned every editor plugin into a
distributed system, since now it has to communicate
asynchronously with the main editor process.
</p><!--l. 84--><p class="indent" >   Consider an update system that took multiple Arvo events
to complete. An ad-hoc higher-level transaction system would
need to be built to roll back the eﬀects of the ﬁrst few events
in case of failure. It’s important for various parts of the
system to be able to emit eﬀects on upgrade; since those
eﬀects would need to be rolled back if a later event in this
upgrade fails, the system would need to maintain a queue of
those events and only apply them once all the other upgrade
events have completed.
                                                
                                                
</p><!--l. 86--><p class="indent" >   Note that the asynchronicity has now spread. Some
eﬀects that would normally be guaranteed to be processed
synchronously might now be asynchronous. Entropy has begun
to take hold, chipping away at the set of invariants the system
is capable of guaranteeing.
</p><!--l. 88--><p class="indent" >   This observation is not purely theoretical. False modularity
was the cause of internal asynchronicity in Clay where it had
to wait for responses in a complex dance with Ford, which was
another vane (Arvo kernel module); moving Ford into Clay
allowed function calls that were synchronous from Clay’s
perspective, which allowed further simpliﬁcations, culminating
in about a twenty percent reduction of source code size of the
Arvo kernelspace.
</p><!--l. 90--><p class="indent" >   Steve Yegge’s “platform rant” (<a 
 id="x1-3002"></a> Yegge, 2011) describes a
Bezosian edict prohibiting synchronous communication among
modules through direct linking. This can be seen as an
acknowledgment of the diﬃculty Amazon was going to have
when it needed to turn internal services external. If your
software needs to run in hell, build it that way from the
start.
</p><!--l. 96--><p class="indent" >   An Urbit ship is not an enterprise SaaS product and does
not need to run in this hell; it exists for just one person, with
natural pressure pushing it in the opposite direction from
Amazon’s web services. Instead of needing a ship’s state and
functionality sharded into microservices strewn across
multiple clusters, an Urbit instance is easiest to manage as
a single server with all its state uniﬁed into one data
structure and its event log stored as one totally ordered
sequence of state updates – the antithesis of a distributed
system.
</p><!--l. 98--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-40001.2"></a>Self-Containment</h4>
<!--l. 100--><p class="noindent" >Before Ford Fusion, each commit to the Clay ﬁlesystem
validated its ﬁles using ﬁletypes (called “marks”) deﬁned by
ﬁles in the previous commit (see <a 
 id="x1-4001"></a> ~lagrev-nocfep (2024),
                                                
                                                
pp. 35–50 in this issue). This could cause bugs if the
ﬁletype deﬁnitions had changed in a backward-incompatible
manner. It also meant a commit could not add both a new
ﬁletype and new ﬁles of that type; instead, you needed two
commits: one to deﬁne the ﬁletypes, and a second to
add ﬁles of that new type. More theoretically, it caused
history-dependence. The validated contents of ﬁles in a
commit could vary based on the history of commits that led to
this one.
</p><!--l. 102--><p class="indent" >   Another way source code failed to be self-contained was
that it had access to symmetry-breaking information at
build-time, namely ship, desk (Urbit’s answer to a git branch),
and (faked) date. A build recipe should be able to shared,
cached, and rerun without dependence on local conditions, so
user code now no longer learns its ship, desk, or date until
runtime.
</p><!--l. 104--><p class="indent" >   Source code also had build-time access to Urbit’s
immutable global namespace, called the “scry namespace”,
which the kernel makes available as an implicit argument to
userspace Hoon code. The scry namespace is immutable and
referentially transparent, i. e. a request must always yield the
same result for all time, but if an agent asks the kernel for a
resource that’s from the future, hosted on another ship, or to
which that agent doesn’t have permission, the kernel will deny
the request.
</p><!--l. 106--><p class="indent" >   If the kernel denies a scry request that user code made
during the build process, the build system has no choice but to
treat it as a nondeterministic error. Nondeterministic errors
can never be fully eradicated, if for no other reason than
that the user always has the option to defenestrate the
machine—there’s nothing deterministic about that. But we try
to minimize them, and especially to minimize uncertainty as
to under what conditions they might occur.
</p><!--l. 108--><p class="indent" >   No build should be killed by the absence of ﬁles outside the
desk, so as of this update, user code can no longer scry at
build time. Once built, userspace programs can scry if run in a
context with a scry handler; a Gall agent’s runtime scry
requests still work just ﬁne.
                                                
                                                
</p><!--l. 110--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">1.3   </span> <a 
 id="x1-50001.3"></a>Order</h4>
<!--l. 112--><p class="noindent" >The ﬁnal kind of failure ﬁxed by Ford Fusion was the lack of
ordered layering during a software update. The most
common form of this failure was that old Ford had a
tendency to try to build userspace code using the previous
version’s standard library. This didn’t work too well,
unsurprisingly.
</p><!--l. 114--><p class="indent" >   Emerging from this underworld required making a number
of changes to the Arvo kernel, Clay, Gall, and the procedure
for kernel updates. To avoid turning into a pillar of salt, I’ll
skip the details of how the old system worked and instead
describe the new update procedure.
</p><!--l. 117--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">2   </span> <a 
 id="x1-60002"></a>How Updates Work Now</h3>
<!--l. 119--><p class="noindent" >These are the layers of the stack that update themselves on
the ﬂy, from lowest to highest:
</p><!--l. 121--><p class="indent" >
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-6002x1">
     <!--l. 122--><p class="noindent" >/sys/hoon:   the   Hoon   language   deﬁnition   and
     compiler
     </p></li>
<li 
  class="enumerate" id="x1-6004x2">
     <!--l. 123--><p class="noindent" >/sys/lull:  common  type  deﬁnitions  for  Arvo,  its
     vanes, and userspace
     </p></li>
<li 
  class="enumerate" id="x1-6006x3">
                                                
                                                
     <!--l. 124--><p class="noindent" >/sys/arvo: the Arvo kernel proper and related type
     deﬁnitions
     </p></li>
<li 
  class="enumerate" id="x1-6008x4">
     <!--l. 125--><p class="noindent" >/sys/zuse: the standard library
     </p></li>
<li 
  class="enumerate" id="x1-6010x5">
     <!--l. 126--><p class="noindent" >Vanes: Arvo kernel modules, including Clay itself
     </p></li>
<li 
  class="enumerate" id="x1-6012x6">
     <!--l. 127--><p class="noindent" >Userspace:  apps,  marks,  ancillary  source  code  like
     libraries, and user data</p></li></ol>
<!--l. 130--><p class="indent" >   An update to one layer necessitates a reload of all layers
above it; e. g., a change to Zuse should trigger updates to the
vanes and userspace. Conversely, an update to a higher layer
should not cause a spurious reload of lower layers, which
should not be aﬀected by the change; for example, an update
to just userspace should not cause any reloads of system
code.
</p><!--l. 132--><p class="indent" >   Clay is responsible for enforcing the layering of updates.
An update to a module is triggered when an attempt is made
to commit a change to Clay that aﬀects one or more ﬁles
needed to build the module. For example, if the <code class="lstinline"><span style="color:#000000">foo</span></code> agent’s
source, deﬁned in <code class="lstinline"><span style="color:#000000">/app/foo/hoon</span></code>, imports the <code class="lstinline"><span style="color:#000000">bar</span></code>
library from <code class="lstinline"><span style="color:#000000">/lib/bar/hoon</span></code>, then a modiﬁcation to
<code class="lstinline"><span style="color:#000000">/lib/bar/hoon</span></code> triggers an update to the <code class="lstinline"><span style="color:#000000">foo</span></code> agent. All
vanes and userspace ﬁles depend on Zuse, which depends on
the Arvo and Hoon sources, so a change to the Hoon, Arvo, or
Zuse sources will trigger updates to all vanes and userspace
ﬁles.
</p><!--l. 134--><p class="indent" >   When asked to perform a commit, Clay determines which
layers need to be updated based on which ﬁles have changed
                                                
                                                
and which modules depend on those ﬁles. For now, all running
programs load their source from the <code class="lstinline"><span style="color:#000000">%base</span></code> desk, so only
changes to <code class="lstinline"><span style="color:#000000">%base</span></code> trigger stateful updates. Files in other desks
can be built, but not installed into the system. This might be
relaxed in the future.
</p><!--l. 136--><p class="indent" >   The process of updating varies by layer. The Hoon and
Zuse layers are stateless, so their newly rebuilt cores (Nock
executables) must be stored (somewhere in the system’s Nock
tree, in memory; remember, Urbit is a single-level store), but
they have no state that would need to be migrated. The
Arvo kernel, vanes, and userspace agents are all live,
stateful programs, so in order to update one of those, the
system must extract the state from the old program, pass
that data into the newly built program, then discard
the old program and store the new one. Arvo and agent
state injection routines can emit eﬀects, but vane updates
cannot.
</p><!--l. 138--><p class="indent" >   To work around this limitation, Gall has a two-phase
update process. First it enters a dormant “pupal” phase that
stores not running agent cores, but only the agent states that
the old Gall had extracted from its agents. When Clay notiﬁes
Gall that its agents have been rebuilt, Gall “molts” back into
normal functionality by loading the agent cores from Clay and
then running their <code class="lstinline"><span style="color:#000000">+on-load</span></code> routines to inject the old
state.<span class="footnote-mark"><a 
href="#fn1x0"><sup class="textsuperscript">1</sup></a></span><a
 id="x1-6013f1"></a> 
</p><!--l. 140--><p class="indent" >   If there’s a change to ﬁles in <code class="lstinline"><span style="color:#000000">/sys</span></code> on the <code class="lstinline"><span style="color:#000000">%base</span></code> desk,
Clay asks Arvo to update kernelspace. Clay sends a sequence
of moves (eﬀects) to Arvo to ask Arvo to perform any
necessary updates to Hoon, the kernel, Zuse, and vanes. This
sequence is terminated by an extra move back to Clay itself,
which will be received by the updated version of Clay after
migrating its state. The rebuilt Clay can then use the newly
rebuilt version of Zuse to rebuild userspace and notify clients
of the update. One client is Gall, which molts when Clay
notiﬁes it.
</p><!--l. 142--><p class="indent" >   Clay triggers updates, but the Arvo kernel is responsible
                                                
                                                
for performing updates to all kernelspace layers, and Gall is
responsible for updating userspace agents. Agents are stored in
Gall’s state, but all other layers are stored directly in
the Arvo core’s state, so the Arvo kernel contains the
routines that reload Hoon, the kernel itself, Zuse, and the
vanes.
</p><!--l. 144--><p class="indent" >   The Arvo kernel reloads itself by compiling the future
version of itself, then calling the new core’s <code class="lstinline"><span style="color:#000000">+load</span></code> routine
with the relevant parts of the old state. The state passed to
the new Arvo now includes not just the vane cores and their
states, but also the Arvo “duct” call stack, which maintains a
stack of queues of moves to be passed from one vane to
another, and a list of eﬀects to emit to Unix at the end of the
current Arvo event. If needed, Arvo could migrate the
outstanding moves themselves – if, say, the duct datatype
changes.
</p><!--l. 146--><p class="indent" >   Passing the Arvo call stack state to new Arvo allows a
kernel update to happen in the middle of a more complex
event without disturbing other sequences of processing steps
happening concurrently in the vanes.
</p><!--l. 148--><p class="indent" >   This entire update process happens in one Arvo event and
doesn’t break event-dispatching semantics. This not only
provides atomic rollback, but allows the update to be
combined with other actions into a larger transaction –
for example, to stage complex changes, user code could
trigger two kernel updates in a row, both in the same
event.
</p><!--l. 150--><p class="indent" >   Note that this is the opposite situation from the entropically
leaking asynchronicity described earlier. Now the guarantees
don’t deteriorate; they can be composed into stronger
guarantees.
</p>
   <h3 class="sectionHead"><span class="titlemark">3   </span> <a 
 id="x1-70003"></a>How Clay Validates a Desk</h3>
<!--l. 155--><p class="noindent" >A desk is Urbit’s answer to a Git repository. It’s almost
identical, except all ﬁles are typed and validated, and
whenever a commit becomes the equivalent of Git’s <code class="lstinline"><span style="color:#000000">HEAD</span></code>,
                                                
                                                
it’s assigned a semantically meaningful revision number, and
all ﬁles are typed and validated.
</p><!--l. 157--><p class="indent" >   If Clay has been asked to perform a commit, it needs to
validate all the ﬁles in this desk and notify all subscribers to
live queries of this desk’s data. Gall, for example, maintains
live queries on builds of its live agents. Validation uses the
Ford build system, which as of this update is no longer a
standalone vane but a core within Clay.
</p><!--l. 159--><p class="indent" >   A Clay commit, like a Git commit, is speciﬁed as the
current value of all its changed ﬁles (and, separately,
references its parent commits by hash), not as the diﬀ from a
parent commit. Unlike Git, Clay is typed, and every ﬁle must
be validated according to its &#x0022;mark&#x0022;. A mark is named like a
ﬁle extension, e. g., <code class="lstinline"><span style="color:#000000">%txt</span></code>, <code class="lstinline"><span style="color:#000000">%png</span></code>, or <code class="lstinline"><span style="color:#000000">%noun</span></code>, and Clay
maintains a mapping from that name to behaviors of values of
that type under various operations. The last segment of any
Clay path speciﬁes the mark to use for operations on that ﬁle,
including validation.
</p><!--l. 161--><p class="indent" >   Mark operations include conversion to and from other
marks (such as converting <code class="lstinline"><span style="color:#000000">%json</span></code> to <code class="lstinline"><span style="color:#000000">%txt</span></code>), revision control
operations (diﬀ, patch, and merge), and validating an untyped
noun. Operations for mark <code class="lstinline"><span style="color:#000000">%foo-bar</span></code> are deﬁned by a core
built using the source code at <code class="lstinline"><span style="color:#000000">/mar/foo-bar/hoon</span></code>, or if
that doesn’t exist, at <code class="lstinline"><span style="color:#000000">/mar/foo/bar/hoon</span></code>.
</p><!--l. 163--><p class="indent" >   Consider a ﬁle at <code class="lstinline"><span style="color:#000000">/web/foo/json</span></code>. In order to validate
this ﬁle, Clay must load the mark deﬁnition core and
use its validation routine to ensure the untyped value of
<code class="lstinline"><span style="color:#000000">/web/foo/json</span></code> is in fact valid <span class="small-caps">json</span>. To obtain this core,
Clay must build the ﬁle at <code class="lstinline"><span style="color:#000000">/mar/json/hoon</span></code> from source
and then process the resulting raw mark core using some mild
metaprogramming to get a standard interface core for dealing
with marks, called a <code class="lstinline"><span style="color:#000000">$dais</span></code>, whose type is deﬁned in
Zuse.
</p><!--l. 165--><p class="indent" >   Since building a source ﬁle only makes sense if the ﬁle
has been validated as a <code class="lstinline"><span style="color:#000000">%hoon</span></code> ﬁle, but mark deﬁnitions
themselves must be built from source, there’s a logical
dependency cycle – who validates the validators? To break
this cycle, Clay hard-codes the validation of <code class="lstinline"><span style="color:#000000">%hoon</span></code> ﬁles. This
allows mark deﬁnitions to be built from source, and in fact
                                                
                                                
any ﬁle can depend on any other ﬁle of any mark as long as
there are no cycles. As of Ford Fusion, Ford performs a cycle
check to ensure acyclicity.
</p><!--l. 167--><p class="indent" >   Since building a ﬁle is a pure function, Clay memoizes
the results of all builds, including builds of marks, mark
conversions, and Hoon source ﬁles. These memoization results
are stored along with the desk and are used by later revisions
of that desk. Future work should allow merge commits to pull
memoized builds from all parents, but for now only the
previous revision of the current desk is used. This is a
major simpliﬁcation of previous Ford architectures, which
maintained much more complex caches with less clear eviction
semantics. Now on every commit, we just throw away any
unused memoized builds from the previous revision’s Ford
cache.
</p><!--l. 169--><p class="indent" >   Once Clay has validated every ﬁle in this new revision of a
desk, it constructs and sends updates to any subscriptions
that other vanes or agents have requested. More Ford builds
may be run to fulﬁll these requests, including builds for
any running agents whose dependencies changed in this
commit.
</p><!--l. 171--><p class="indent" >   When Gall receives a newly rebuilt agent from Clay, it
calls the gate produced by the <code class="lstinline"><span style="color:#000000">+on-load</span></code> arm of the new
agent with the state extracted from the old agent. If there is a
crash in any <code class="lstinline"><span style="color:#000000">+on-load</span></code> calls or in the handling of any eﬀects
they emit (which can include more agent activations),
then the whole event crashes, canceling the commit. This
eﬀectively gives any agent the ability to abort a commit by
crashing.
</p><!--l. 173--><p class="indent" >   It is a bit counterintuitive that an app reload failure could
prevent a kernel update. The reason is that we don’t want the
system to update itself into a broken state. An Urbit can be
rendered practically unusable by the presence of broken
agents, even if the kernel hasn’t lost integrity, so it’s kinder
to the user not to break their agents by installing an
incompatible kernel update. This also puts virtuous pressure
on kernel developers not to “break userspace”, the importance
of which has been insisted on for decades by Linus Torvalds,
among others.
                                                
                                                
</p><!--l. 175--><p class="indent" >   If an agent does crash a commit event that included a
kernel update, the attempted commit is now trivially rolled
back, and the system can deliver an error message to the
user. This does not leave the system in an inconsistent or
stuck state, so the user could modify the failing agent
and try the kernel update again later. Supporting better
workﬂows for keeping third-party agents up-to-date will be an
important aspect of Urbit’s upcoming software distribution
work.
</p><!--l. 178--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x1-80004"></a>Ford Build Semantics</h3>
<!--l. 180--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-90004.1"></a>The Three Types of Ford Builds: Files, Marks, and
Casts</h4>
<!--l. 182--><p class="noindent" >The Ford build semantics have been simpliﬁed. There are now
three kinds of builds that Ford can perform: ﬁles, marks, and
casts, all of which happen synchronously as function calls
inside Clay and are available (without memoization) as scry
interfaces.
</p><!--l. 184--><p class="noindent" >
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">4.1.1   </span> <a 
 id="x1-100004.1.1"></a>File Builds</h5>
<!--l. 186--><p class="noindent" >A ﬁle build takes in a ﬁlepath containing Ford runes and Hoon
source, runs the Ford runes to perform imports, and then
compiles the source, producing a <code class="lstinline"><span style="color:#000000">$vase</span></code>, a noun tagged with
its Hoon type.
</p><!--l. 189--><p class="indent" >   Clay exposes ﬁle builds into the scry namespace with
<code class="lstinline"><span style="color:#000000">%ca</span></code>: as an example, <code class="lstinline"><span style="color:#000000">.^</span><span style="color:#000000">(</span><span style="color:#000000">vase</span><span style="color:#000000"> </span><span style="color:#000000">%ca</span><span style="color:#000000"> </span><span style="color:#000000">/~zod/base/3</span></code>
<code class="lstinline"><span style="color:#000000">/lib/sole/hoon</span><span style="color:#000000">)</span></code> will build the <code class="lstinline"><span style="color:#000000">sole</span></code> library.
                                                
                                                
</p><!--l. 191--><p class="noindent" >
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">4.1.2   </span> <a 
 id="x1-110004.1.2"></a>Mark Builds</h5>
<!--l. 193--><p class="noindent" >A mark build produces a <code class="lstinline"><span style="color:#000000">$dais</span></code> mark-interface core. It ﬁrst
performs a ﬁle build on the Hoon ﬁle in <code class="lstinline"><span style="color:#000000">/mar</span></code> that deﬁnes the
mark core, then it does some metaprogramming to make the
operations more convenient to use. If the raw mark core
delegated revision control operations to another mark core,
the mark build will also load the delegate mark core and
resolve the result into the <code class="lstinline"><span style="color:#000000">$dais</span></code>.
</p><!--l. 196--><p class="indent" >   Clay exposes mark builds into the scry namespace with
<code class="lstinline"><span style="color:#000000">%cb</span></code>: as an example, <code class="lstinline"><span style="color:#000000">.^</span><span style="color:#000000">(</span><span style="color:#000000">dais:clay</span><span style="color:#000000"> </span><span style="color:#000000">%cb</span><span style="color:#000000"> </span><span style="color:#000000">/~zod/base/3</span></code>
<code class="lstinline"><span style="color:#000000">/mar/foo/hoon</span><span style="color:#000000">)</span></code> builds a <code class="lstinline"><span style="color:#000000">$dais</span></code> for the <code class="lstinline"><span style="color:#000000">%foo</span></code> mark.
</p><!--l. 198--><p class="noindent" >
</p>
   <h5 class="subsubsectionHead"><span class="titlemark">4.1.3   </span> <a 
 id="x1-120004.1.3"></a>Cast Builds</h5>
<!--l. 200--><p class="noindent" >A cast build produces a <code class="lstinline"><span style="color:#000000">$tube</span></code>: a gate that takes a value of
one mark as input and converts it to a valid value of
another mark or crashes. To convert from mark <code class="lstinline"><span style="color:#000000">%foo</span></code>
to mark <code class="lstinline"><span style="color:#000000">%bar</span></code>, Clay tries the following operations, in
order:
</p><!--l. 202--><p class="indent" >
     </p><ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-12002x1">
     <!--l. 203--><p class="noindent" >direct grow from ‘
     </p></li>
<li 
  class="enumerate" id="x1-12004x2">
     <!--l. 204--><p class="noindent" >direct grab from ‘
     </p></li>
                                                
                                                
<li 
  class="enumerate" id="x1-12006x3">
     <!--l. 205--><p class="noindent" >indirect jump from ‘
     </p></li>
<li 
  class="enumerate" id="x1-12008x4">
     <!--l. 206--><p class="noindent" >indirect grab from ‘</p></li></ol>
<!--l. 209--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">%foo</span></code> mark can “grow to” <code class="lstinline"><span style="color:#000000">%bar</span></code> by providing an arm
in its <code class="lstinline"><span style="color:#000000">+grow</span></code> core named <code class="lstinline"><span style="color:#000000">+bar</span></code>. <code class="lstinline"><span style="color:#000000">%bar</span></code> can convert from <code class="lstinline"><span style="color:#000000">%foo</span></code>
using a <code class="lstinline"><span style="color:#000000">+foo</span></code> arm in its <code class="lstinline"><span style="color:#000000">+grab</span></code> core. <code class="lstinline"><span style="color:#000000">%foo</span></code> can also chain a
conversion through an intermediary using an arm in its <code class="lstinline"><span style="color:#000000">+jump</span></code>
core, and <code class="lstinline"><span style="color:#000000">%bar</span></code> can specify an “indirect grab” by having a
<code class="lstinline"><span style="color:#000000">+grab</span></code> arm produce a delegate mark instead of directly
deﬁning a conversion gate.
</p><!--l. 212--><p class="indent" >   Clay exposes cast builds into the scry namespace with
<code class="lstinline"><span style="color:#000000">%cc</span></code>: as an example, <code class="lstinline"><span style="color:#000000">.^</span><span style="color:#000000">(</span><span style="color:#000000">tube:clay</span><span style="color:#000000"> </span><span style="color:#000000">%cc</span><span style="color:#000000"> </span><span style="color:#000000">/~zod/base/3</span></code>
<code class="lstinline"><span style="color:#000000">/foo/bar</span><span style="color:#000000">)</span></code> builds a <code class="lstinline"><span style="color:#000000">$tube</span></code> conversion gate from <code class="lstinline"><span style="color:#000000">%foo</span></code> to
<code class="lstinline"><span style="color:#000000">%bar</span></code>.
</p><!--l. 214--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">4.2   </span> <a 
 id="x1-130004.2"></a>Ford Runes</h4>
<!--l. 216--><p class="noindent" >There are now only seven Ford runes. A ﬁle can contain zero,
one, or many of each, but each Ford expression can only be
one line, and they must be in the standard order of <code class="lstinline"><span style="color:#000000">/-</span></code>s, <code class="lstinline"><span style="color:#000000">/+</span></code>s,
<code class="lstinline"><span style="color:#000000">/=</span></code>s, and then <code class="lstinline"><span style="color:#000000">/*</span></code>s.
</p>
   <!--l. 218-->
<pre class="lstlisting" id="listing-68"><span class="label"><a 
 id="x1-13001r1"></a></span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">/-</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">foo,</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">*bar,</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">baz=qux</span></span></pre>
<!--l. 222--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">/-</span></code> rune imports a structures ﬁle from <code class="lstinline"><span style="color:#000000">/sur</span></code>. You can
import it as just <code class="lstinline"><span style="color:#000000">foo</span></code>, in which case the build result of
that ﬁle (usually a core with mold deﬁnitions) will be
pinned into the compilation subject with the face <code class="lstinline"><span style="color:#000000">foo</span></code>.
If you preﬁx it with a <code class="lstinline"><span style="color:#000000">*</span></code> as in <code class="lstinline"><span style="color:#000000">*bar</span></code>, the result will be
pinned into the subject with no face; if the structures
                                                
                                                
ﬁle compiled to a core, this exposes all the arms into
the namespace of the compilation subject. Finally, if
you import it as <code class="lstinline"><span style="color:#000000">baz=qux</span></code>, the <code class="lstinline"><span style="color:#000000">baz</span></code> face will be applied
instead of <code class="lstinline"><span style="color:#000000">qux</span></code>. This is similar to “import as” in other
languages.
</p>
   <!--l. 224-->
<pre class="lstlisting" id="listing-78"><span class="label"><a 
 id="x1-13002r1"></a></span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">/+</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">foo,</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">*bar,</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">baz=qux</span></span></pre>
<!--l. 228--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">/+</span></code> rune imports a library ﬁle from <code class="lstinline"><span style="color:#000000">/lib</span></code>. Aside from
the diﬀerent source folder, the syntax and semantics are the
same as for <code class="lstinline"><span style="color:#000000">/-</span></code>.
</p>
   <!--l. 230-->
<pre class="lstlisting" id="listing-82"><span class="label"><a 
 id="x1-13003r1"></a></span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">/=</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">clay-raw</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">/sys/vane/clay</span></span></pre>
<!--l. 234--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">/=</span></code> rune imports the result of building a Hoon ﬁle
from a user-speciﬁed path (the second argument), wrapping it
in a face speciﬁed by the ﬁrst argument. The ﬁnal <code class="lstinline"><span style="color:#000000">/hoon</span></code> at
the end of the path must be omitted. This is mostly
useful for importing a ﬁle for testing. The ﬁle at the
speciﬁed path will be built as a normal userspace Hoon ﬁle;
i. e. its compilation subject will be Zuse augmented with
the results of any Ford runes it has at the top of the
ﬁle.
</p>
   <!--l. 236-->
<pre class="lstlisting" id="listing-85"><span class="label"><a 
 id="x1-13004r1"></a></span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">/*</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">hello-gen</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">%hoon</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">/gen/hello/hoon</span></span></pre>
<!--l. 240--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">/*</span></code> rune imports the contents of a ﬁle in the desk,
speciﬁed as the third argument with the full path including
the trailing mark, converted to the mark speciﬁed by
the second argument, and pinned into the compilation
subject wrapped in the face speciﬁed by the ﬁrst argument.
This can be used to import static data at build-time,
such as a data ﬁle, a media ﬁle, or, in the case of this
                                                
                                                
example, a Hoon ﬁle as source text rather than already
built.
</p><!--l. 242--><p class="indent" >   A valid userspace Hoon ﬁle must contain a nonempty list
of <code class="lstinline"><span style="color:#000000">hoon</span></code>s (Hoon source expressions) below the Ford runes,
separated by gap (more than one space, or at least one
newline). The system wraps this list of <code class="lstinline"><span style="color:#000000">hoon</span></code>s in a <code class="lstinline"><span style="color:#000000">=~</span></code>
expression so that the result of the previous <code class="lstinline"><span style="color:#000000">hoon</span></code> is used as
the subject of the next <code class="lstinline"><span style="color:#000000">hoon</span></code>. The result of the Ford runes is
used as the compilation subject for this <code class="lstinline"><span style="color:#000000">=~</span></code> <code class="lstinline"><span style="color:#000000">hoon</span></code>; informally,
the shape of the compilation subject can be thought of
as:
</p>
   <!--l. 244-->
<pre class="lstlisting" id="listing-94"><span class="label"><a 
 id="x1-13005r1"></a></span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">:*</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">fastar-2</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">fastar-1</span></span> 
<span class="label"><a 
 id="x1-13006r2"></a></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">fastis-2</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">fastis-1</span></span> 
<span class="label"><a 
 id="x1-13007r3"></a></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">faslus-2</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">faslus-1</span></span> 
<span class="label"><a 
 id="x1-13008r4"></a></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">fashep-2</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">fashep-1</span></span> 
<span class="label"><a 
 id="x1-13009r5"></a><span 
class="ec-lmr-5">5</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">&#x003C;zuse&#x003E;</span></span> 
<span class="label"><a 
 id="x1-13010r6"></a></span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">==</span></span></pre>
   <!--l. 253-->
<pre class="lstlisting" id="listing-95"><span class="label"><a 
 id="x1-13011r1"></a></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">/</span><span 
class="ec-lmtk-10x-x-90">$</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">some-face</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">%from-mark</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">%to-mark</span></span></pre>
<!--l. 257--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">/$</span></code> rune imports a mark conversion gate between
two types. These are marks on the same desk as the
ﬁle.
</p>
   <!--l. 259-->
<pre class="lstlisting" id="listing-97"><span class="label"><a 
 id="x1-13012r1"></a></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">/</span><span 
class="ec-lmtt-9">~</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">some-face</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">some-type</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">/some/directory</span></span></pre>
<!--l. 263--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">/~</span></code> rune imports, builds, evaluates, and pins the
results of many <code class="lstinline"><span style="color:#000000">hoon</span></code> ﬁles in a directory. Each Hoon ﬁle in the
speciﬁed directory will be built and evaluated. The result of
evaluating each ﬁle will be added to a <code class="lstinline"><span style="color:#000000">++map</span></code> and pinned with
the speciﬁed face <code class="lstinline"><span style="color:#000000">some-face</span></code>. The keys of the map will be
the name of each ﬁle, and the values of the map will be the
result of evaluating each ﬁle and casting its result to the type
speciﬁed <code class="lstinline"><span style="color:#000000">some-type</span></code>.
</p><!--l. 265--><p class="indent" >   All of the <code class="lstinline"><span style="color:#000000">hoon</span></code> ﬁles in the speciﬁed directory, when
evaluated, must produce data of a type that nests under the
type speciﬁed <code class="lstinline"><span style="color:#000000">some-type</span></code>. File with a mark other than
<code class="lstinline"><span style="color:#000000">%hoon</span></code> will be ignored.
                                                
                                                
</p>
   <!--l. 267-->
<pre class="lstlisting" id="listing-106"><span class="label"><a 
 id="x1-13013r1"></a></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#404040"><span 
class="ec-lmtk-10x-x-90">/%</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">some-face</span></span><span style="color:#000000"> </span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ec-lmtt-9">%some-mark</span></span></pre>
<!--l. 271--><p class="indent" >   The <code class="lstinline"><span style="color:#000000">/%</span></code> rune imports a mark deﬁnition from the <code class="lstinline"><span style="color:#000000">/mar</span></code>
directory. The mark deﬁnition will be built and pinned with
the speciﬁed face <code class="lstinline"><span style="color:#000000">some-face</span></code>.
</p><!--l. 274--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5   </span> <a 
 id="x1-140005"></a>Future Work</h3>
<!--l. 276--><p class="noindent" >Urbit still needs to make better use of desks other than <code class="lstinline"><span style="color:#000000">%base</span></code>
and the development process should be adjusted given the
tighter coupling between source code and kernel and tighter
criteria for accepting an update.
</p><!--l. 278--><p class="indent" >   This work also hopefully provides a good foundation of a
package management and software distribution system for
Urbit. As ~wicdev-wisryt has said, a user should be able to
run <code class="lstinline"><span style="color:#000000">|install</span><span style="color:#000000"> </span><span style="color:#000000">~norsyr-torryn</span><span style="color:#000000"> </span><span style="color:#000000">%canvas</span></code> to load and
build remote source. No one should experience dependency
hell on Urbit, but we’re not there yet.
</p><!--l. 280--><p class="indent" >   At least now, building a desk has no dependencies, other
than a Ford with a compatible Hoon compiler. No decisions
have been made on this yet, but Ford might get moved to
inside the desk, possibly by making Zuse callable. This could
allow a desk to expose a Nock interface in addition to a typed
Hoon interface, which could even let a desk be used as a “pill”
bootloader.
</p><!--l. 283--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">6   </span> <a 
 id="x1-150006"></a>Conclusion</h3>
<!--l. 285--><p class="noindent" >~littel-ponnys and I (~rovnys-ricfer) spent most of 2018
rewriting Ford with the intent of improving its performance.
                                                
                                                
Compared to its predecessor, its result was better in some
ways but worse in others. The caching system was labyrinthine
and poorly factored, making the system diﬃcult to debug or
prove correct, even informally. Some things were faster, but
the caching and dependency tracking were actually complex
enough that a number of common operations, like mark
conversion, were too slow.
</p><!--l. 287--><p class="indent" >   In early 2020, ~master-morzod suggested moving Ford into
Clay to reduce asynchronicity. It seemed absurd at ﬁrst, but at
some point I realized I could combine that idea with a simpler
build-caching scheme and self-contained desk builds, and
~wicdev-wisryt realized he could use that to further simplify
Clay’s commit and merge code, which he did as part of this
project.
</p><!--l. 289--><p class="indent" >   The ﬁrst time I rewrote Ford, it took me six months, with
help from ~littel-ponnys, and it weighed in at 6,000 lines of
code. The second time, in late 2018, took a few weeks. The
third time, in January 2020, took a week. I wrote <code class="lstinline"><span style="color:#000000">+ford</span></code> in
Ford Fusion in one long day, and it’s about 500 lines of
synchronous, functional code.
</p><!--l. 291--><p class="indent" >   It has taken me two or three years to understand this
problem as well as I do, and I expect there are parts
of it I still don’t understand. The code itself isn’t the
issue; it’s ﬁnding the right answer to ontological and
teleological questions. What <span 
class="ec-lmri-10">is </span>Ford? What will it be in a
hundred years? I’m conﬁdent Ford Fusion is more similar
than its predecessor to the Ford of 2120, because it’s
smaller, more functional, and easier to understand and
administer.
</p><!--l. 293--><p class="indent" >   As an engineering discipline and organizational practice,
working on a system intended to be frozen yields surprising
simpliﬁcations like this every so often. Urbit is now reaching
the point where we’re starting to see more of the obsidian
edges of the frozen future system emerge from the lava. <img 
src="ustj-logo-.png" alt="PIC"  
 />
</p><!--l. 297--><p class="noindent" >
</p>
                                                
                                                
   <h3 class="sectionHead"><a 
 id="x1-16000"></a>References</h3>
<!--l. 297--><p class="noindent" >
   </p><dl class="thebibliography"><dt id="X0-Blow2019" class="thebibliography">
</dt><dd 
id="bib-1" class="thebibliography">
   <!--l. 297--><p class="noindent" ><a 
 id="cite.0@Blow2019"></a>Blow, Jonathan
   (2019)
   “Preventing
   the
   Collapse
   of
   Civilization”.
   <span class="small-caps">url</span>:
   <a 
href="https://youtu.be/pW-SOdj4Kkk?t=2547" class="url" >https://youtu.be/pW-SOdj4Kkk?t=2547</a>
   (visited
   on
   ~2024.8.30).
   </p></dd><dt id="X0-Davis2024" class="thebibliography">
</dt><dd 
id="bib-2" class="thebibliography">
   <!--l. 297--><p class="noindent" ><a 
 id="cite.0@Davis2024"></a>~lagrev-nocfep, N. E. Davis
   (2024).
   “Clay
   as
   a
   Typed
   Revision
   Control
   System.”
   In:
   <span 
class="ec-lmri-10">Urbit</span>
   <span 
class="ec-lmri-10">Systems</span>
   <span 
class="ec-lmri-10">Technical</span>
   <span 
class="ec-lmri-10">Journal</span>
   1.2,
   pp. 35–50.
                                                
                                                
   </p></dd><dt id="X0-Yegge2011" class="thebibliography">
</dt><dd 
id="bib-3" class="thebibliography">
   <!--l. 297--><p class="noindent" ><a 
 id="cite.0@Yegge2011"></a>Yegge, Steve
   (2011)
   “Stevey’s
   Google
   Platforms
   Rant”.
   <span class="small-caps">url</span>:
   <a 
href="https://gist.github.com/chitchcock/1281611" class="url" >https://gist.github.com/chitchcock/1281611</a>
   (visited
   on
   ~2024.8.30).</p></dd></dl>
    

<h3 class="sectionHead"><a id="x1-65536"></a>Footnotes</h3><p class="noindent" >
      <div class="footnote-text">
  <!--l. 51--><p class="indent" >     <span class="footnote-mark"><a
 id="fn1x0">   <sup class="textsuperscript">1</sup></a></span><span
class="ec-lmr-8">Including agent state upgrade handling.</span><a href="#x1-6013f1">⤴</a></p></div></p></div>

</body>
</html>
                                                


